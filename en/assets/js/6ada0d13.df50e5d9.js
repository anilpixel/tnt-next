"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6812],{85794:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>i,contentTitle:()=>d,metadata:()=>s,toc:()=>p,default:()=>u});var a=n(7896),r=n(31461),l=(n(2784),n(30876)),o=["components"],i={tags:["Components"],type:"Data Display",title:"Tree"},d=void 0,s={unversionedId:"components/data-display/tree",id:"components/data-display/tree",isDocsHomePage:!1,title:"Tree",description:"---",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/components/data-display/tree.md",sourceDirName:"components/data-display",slug:"/components/data-display/tree",permalink:"/tnt-next/en/docs/components/data-display/tree",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/components/data-display/tree.md",tags:[{label:"Components",permalink:"/tnt-next/en/docs/tags/components"}],version:"current",frontMatter:{tags:["Components"],type:"Data Display",title:"Tree"},sidebar:"componentsSidebar",previous:{title:"Tooltip",permalink:"/tnt-next/en/docs/components/data-display/tooltip"},next:{title:"Alert",permalink:"/tnt-next/en/docs/components/feedback/alert"}},p=[{value:"When To Use",id:"when-to-use",children:[],level:2},{value:"\u793a\u4f8b",id:"\u793a\u4f8b",children:[{value:"Basic",id:"basic",children:[],level:3},{value:"Controlled Tree",id:"controlled-tree",children:[],level:3},{value:"draggable",id:"draggable",children:[],level:3},{value:"load data asynchronously",id:"load-data-asynchronously",children:[],level:3},{value:"Searchable",id:"searchable",children:[],level:3},{value:"Tree with line",id:"tree-with-line",children:[],level:3},{value:"Customize Icon",id:"customize-icon",children:[],level:3},{value:"directory",id:"directory",children:[],level:3},{value:"Customize collapse/expand icon",id:"customize-collapseexpand-icon",children:[],level:3}],level:2},{value:"API",id:"api",children:[{value:"Tree props",id:"tree-props",children:[],level:3},{value:"TreeNode props",id:"treenode-props",children:[],level:3},{value:"DirectoryTree props",id:"directorytree-props",children:[],level:3}],level:2},{value:"Note",id:"note",children:[],level:2},{value:"FAQ",id:"faq",children:[{value:"How to hide file icon when use showLine?",id:"how-to-hide-file-icon-when-use-showline",children:[],level:3}],level:2}],c={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("hr",null),(0,l.kt)("p",null,"A hierarchical list structure component."),(0,l.kt)("h2",{id:"when-to-use"},"When To Use"),(0,l.kt)("p",null,"Almost anything can be represented in a tree structure. Examples include directories, organization hierarchies, biological classifications, countries, etc. The ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree")," component is a way of representing the hierarchical relationship between these things. You can also expand, collapse, and select a treeNode within a ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree"),"."),(0,l.kt)("h2",{id:"\u793a\u4f8b"},"\u793a\u4f8b"),(0,l.kt)("h3",{id:"basic"},"Basic"),(0,l.kt)("p",null,"The most basic usage, tell you how to use checkable, selectable, disabled, defaultExpandKeys, and etc."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const { TreeNode } = Tree;\n\nclass Demo extends React.Component {\n  onSelect = (selectedKeys, info) => {\n    console.log(\'selected\', selectedKeys, info);\n  };\n\n  onCheck = (checkedKeys, info) => {\n    console.log(\'onCheck\', checkedKeys, info);\n  };\n\n  render() {\n    return (\n      <Tree\n        checkable\n        defaultExpandedKeys={[\'0-0-0\', \'0-0-1\']}\n        defaultSelectedKeys={[\'0-0-0\', \'0-0-1\']}\n        defaultCheckedKeys={[\'0-0-0\', \'0-0-1\']}\n        onSelect={this.onSelect}\n        onCheck={this.onCheck}\n      >\n        <TreeNode title="parent 1" key="0-0">\n          <TreeNode title="parent 1-0" key="0-0-0" disabled>\n            <TreeNode title="leaf" key="0-0-0-0" disableCheckbox />\n            <TreeNode title="leaf" key="0-0-0-1" />\n          </TreeNode>\n          <TreeNode title="parent 1-1" key="0-0-1">\n            <TreeNode title={<span style={{ color: \'#1890ff\' }}>sss</span>} key="0-0-1-0" />\n          </TreeNode>\n        </TreeNode>\n      </Tree>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n')),(0,l.kt)("h3",{id:"controlled-tree"},"Controlled Tree"),(0,l.kt)("p",null,"Controlled mode lets parent nodes reflect the status of child nodes more intelligently."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"const { TreeNode } = Tree;\n\nconst treeData = [\n  {\n    title: '0-0',\n    key: '0-0',\n    children: [\n      {\n        title: '0-0-0',\n        key: '0-0-0',\n        children: [\n          { title: '0-0-0-0', key: '0-0-0-0' },\n          { title: '0-0-0-1', key: '0-0-0-1' },\n          { title: '0-0-0-2', key: '0-0-0-2' },\n        ],\n      },\n      {\n        title: '0-0-1',\n        key: '0-0-1',\n        children: [\n          { title: '0-0-1-0', key: '0-0-1-0' },\n          { title: '0-0-1-1', key: '0-0-1-1' },\n          { title: '0-0-1-2', key: '0-0-1-2' },\n        ],\n      },\n      {\n        title: '0-0-2',\n        key: '0-0-2',\n      },\n    ],\n  },\n  {\n    title: '0-1',\n    key: '0-1',\n    children: [\n      { title: '0-1-0-0', key: '0-1-0-0' },\n      { title: '0-1-0-1', key: '0-1-0-1' },\n      { title: '0-1-0-2', key: '0-1-0-2' },\n    ],\n  },\n  {\n    title: '0-2',\n    key: '0-2',\n  },\n];\n\nclass Demo extends React.Component {\n  state = {\n    expandedKeys: ['0-0-0', '0-0-1'],\n    autoExpandParent: true,\n    checkedKeys: ['0-0-0'],\n    selectedKeys: [],\n  };\n\n  onExpand = expandedKeys => {\n    console.log('onExpand', expandedKeys);\n    // if not set autoExpandParent to false, if children expanded, parent can not collapse.\n    // or, you can remove all expanded children keys.\n    this.setState({\n      expandedKeys,\n      autoExpandParent: false,\n    });\n  };\n\n  onCheck = checkedKeys => {\n    console.log('onCheck', checkedKeys);\n    this.setState({ checkedKeys });\n  };\n\n  onSelect = (selectedKeys, info) => {\n    console.log('onSelect', info);\n    this.setState({ selectedKeys });\n  };\n\n  renderTreeNodes = data =>\n    data.map(item => {\n      if (item.children) {\n        return (\n          <TreeNode title={item.title} key={item.key} dataRef={item}>\n            {this.renderTreeNodes(item.children)}\n          </TreeNode>\n        );\n      }\n      return <TreeNode key={item.key} {...item} />;\n    });\n\n  render() {\n    return (\n      <Tree\n        checkable\n        onExpand={this.onExpand}\n        expandedKeys={this.state.expandedKeys}\n        autoExpandParent={this.state.autoExpandParent}\n        onCheck={this.onCheck}\n        checkedKeys={this.state.checkedKeys}\n        onSelect={this.onSelect}\n        selectedKeys={this.state.selectedKeys}\n      >\n        {this.renderTreeNodes(treeData)}\n      </Tree>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n")),(0,l.kt)("h3",{id:"draggable"},"draggable"),(0,l.kt)("p",null,"Drag treeNode to insert after the other treeNode or insert into the other parent TreeNode."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"const { TreeNode } = Tree;\n\nconst x = 3;\nconst y = 2;\nconst z = 1;\nconst gData = [];\n\nconst generateData = (_level, _preKey, _tns) => {\n  const preKey = _preKey || '0';\n  const tns = _tns || gData;\n\n  const children = [];\n  for (let i = 0; i < x; i++) {\n    const key = `${preKey}-${i}`;\n    tns.push({ title: key, key });\n    if (i < y) {\n      children.push(key);\n    }\n  }\n  if (_level < 0) {\n    return tns;\n  }\n  const level = _level - 1;\n  children.forEach((key, index) => {\n    tns[index].children = [];\n    return generateData(level, key, tns[index].children);\n  });\n};\ngenerateData(z);\n\nclass Demo extends React.Component {\n  state = {\n    gData,\n    expandedKeys: ['0-0', '0-0-0', '0-0-0-0'],\n  };\n\n  onDragEnter = info => {\n    console.log(info);\n    // expandedKeys \u9700\u8981\u53d7\u63a7\u65f6\u8bbe\u7f6e\n    // this.setState({\n    //   expandedKeys: info.expandedKeys,\n    // });\n  };\n\n  onDrop = info => {\n    console.log(info);\n    const dropKey = info.node.props.eventKey;\n    const dragKey = info.dragNode.props.eventKey;\n    const dropPos = info.node.props.pos.split('-');\n    const dropPosition = info.dropPosition - Number(dropPos[dropPos.length - 1]);\n\n    const loop = (data, key, callback) => {\n      data.forEach((item, index, arr) => {\n        if (item.key === key) {\n          return callback(item, index, arr);\n        }\n        if (item.children) {\n          return loop(item.children, key, callback);\n        }\n      });\n    };\n    const data = [...this.state.gData];\n\n    // Find dragObject\n    let dragObj;\n    loop(data, dragKey, (item, index, arr) => {\n      arr.splice(index, 1);\n      dragObj = item;\n    });\n\n    if (!info.dropToGap) {\n      // Drop on the content\n      loop(data, dropKey, item => {\n        item.children = item.children || [];\n        // where to insert \u793a\u4f8b\u6dfb\u52a0\u5230\u5c3e\u90e8\uff0c\u53ef\u4ee5\u662f\u968f\u610f\u4f4d\u7f6e\n        item.children.push(dragObj);\n      });\n    } else if (\n      (info.node.props.children || []).length > 0 && // Has children\n      info.node.props.expanded && // Is expanded\n      dropPosition === 1 // On the bottom gap\n    ) {\n      loop(data, dropKey, item => {\n        item.children = item.children || [];\n        // where to insert \u793a\u4f8b\u6dfb\u52a0\u5230\u5934\u90e8\uff0c\u53ef\u4ee5\u662f\u968f\u610f\u4f4d\u7f6e\n        item.children.unshift(dragObj);\n      });\n    } else {\n      let ar;\n      let i;\n      loop(data, dropKey, (item, index, arr) => {\n        ar = arr;\n        i = index;\n      });\n      if (dropPosition === -1) {\n        ar.splice(i, 0, dragObj);\n      } else {\n        ar.splice(i + 1, 0, dragObj);\n      }\n    }\n\n    this.setState({\n      gData: data,\n    });\n  };\n\n  render() {\n    const loop = data =>\n      data.map(item => {\n        if (item.children && item.children.length) {\n          return (\n            <TreeNode key={item.key} title={item.title}>\n              {loop(item.children)}\n            </TreeNode>\n          );\n        }\n        return <TreeNode key={item.key} title={item.title} />;\n      });\n    return (\n      <Tree\n        className=\"draggable-tree\"\n        defaultExpandedKeys={this.state.expandedKeys}\n        draggable\n        blockNode\n        onDragEnter={this.onDragEnter}\n        onDrop={this.onDrop}\n      >\n        {loop(this.state.gData)}\n      </Tree>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n")),(0,l.kt)("h3",{id:"load-data-asynchronously"},"load data asynchronously"),(0,l.kt)("p",null,"To load data asynchronously when click to expand a treeNode."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"const { TreeNode } = Tree;\n\nclass Demo extends React.Component {\n  state = {\n    treeData: [\n      { title: 'Expand to load', key: '0' },\n      { title: 'Expand to load', key: '1' },\n      { title: 'Tree Node', key: '2', isLeaf: true },\n    ],\n  };\n\n  onLoadData = treeNode =>\n    new Promise(resolve => {\n      if (treeNode.props.children) {\n        resolve();\n        return;\n      }\n      setTimeout(() => {\n        treeNode.props.dataRef.children = [\n          { title: 'Child Node', key: `${treeNode.props.eventKey}-0` },\n          { title: 'Child Node', key: `${treeNode.props.eventKey}-1` },\n        ];\n        this.setState({\n          treeData: [...this.state.treeData],\n        });\n        resolve();\n      }, 1000);\n    });\n\n  renderTreeNodes = data =>\n    data.map(item => {\n      if (item.children) {\n        return (\n          <TreeNode title={item.title} key={item.key} dataRef={item}>\n            {this.renderTreeNodes(item.children)}\n          </TreeNode>\n        );\n      }\n      return <TreeNode key={item.key} {...item} dataRef={item} />;\n    });\n\n  render() {\n    return <Tree loadData={this.onLoadData}>{this.renderTreeNodes(this.state.treeData)}</Tree>;\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n")),(0,l.kt)("h3",{id:"searchable"},"Searchable"),(0,l.kt)("p",null,"Searchable Tree."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"const { TreeNode } = Tree;\nconst { Search } = Input;\n\nconst x = 3;\nconst y = 2;\nconst z = 1;\nconst gData = [];\n\nconst generateData = (_level, _preKey, _tns) => {\n  const preKey = _preKey || '0';\n  const tns = _tns || gData;\n\n  const children = [];\n  for (let i = 0; i < x; i++) {\n    const key = `${preKey}-${i}`;\n    tns.push({ title: key, key });\n    if (i < y) {\n      children.push(key);\n    }\n  }\n  if (_level < 0) {\n    return tns;\n  }\n  const level = _level - 1;\n  children.forEach((key, index) => {\n    tns[index].children = [];\n    return generateData(level, key, tns[index].children);\n  });\n};\ngenerateData(z);\n\nconst dataList = [];\nconst generateList = data => {\n  for (let i = 0; i < data.length; i++) {\n    const node = data[i];\n    const { key } = node;\n    dataList.push({ key, title: key });\n    if (node.children) {\n      generateList(node.children);\n    }\n  }\n};\ngenerateList(gData);\n\nconst getParentKey = (key, tree) => {\n  let parentKey;\n  for (let i = 0; i < tree.length; i++) {\n    const node = tree[i];\n    if (node.children) {\n      if (node.children.some(item => item.key === key)) {\n        parentKey = node.key;\n      } else if (getParentKey(key, node.children)) {\n        parentKey = getParentKey(key, node.children);\n      }\n    }\n  }\n  return parentKey;\n};\n\nclass SearchTree extends React.Component {\n  state = {\n    expandedKeys: [],\n    searchValue: '',\n    autoExpandParent: true,\n  };\n\n  onExpand = expandedKeys => {\n    this.setState({\n      expandedKeys,\n      autoExpandParent: false,\n    });\n  };\n\n  onChange = e => {\n    const { value } = e.target;\n    const expandedKeys = dataList\n      .map(item => {\n        if (item.title.indexOf(value) > -1) {\n          return getParentKey(item.key, gData);\n        }\n        return null;\n      })\n      .filter((item, i, self) => item && self.indexOf(item) === i);\n    this.setState({\n      expandedKeys,\n      searchValue: value,\n      autoExpandParent: true,\n    });\n  };\n\n  render() {\n    const { searchValue, expandedKeys, autoExpandParent } = this.state;\n    const loop = data =>\n      data.map(item => {\n        const index = item.title.indexOf(searchValue);\n        const beforeStr = item.title.substr(0, index);\n        const afterStr = item.title.substr(index + searchValue.length);\n        const title =\n          index > -1 ? (\n            <span>\n              {beforeStr}\n              <span style={{ color: '#f50' }}>{searchValue}</span>\n              {afterStr}\n            </span>\n          ) : (\n            <span>{item.title}</span>\n          );\n        if (item.children) {\n          return (\n            <TreeNode key={item.key} title={title}>\n              {loop(item.children)}\n            </TreeNode>\n          );\n        }\n        return <TreeNode key={item.key} title={title} />;\n      });\n    return (\n      <div>\n        <Search style={{ marginBottom: 8 }} placeholder=\"Search\" onChange={this.onChange} />\n        <Tree\n          onExpand={this.onExpand}\n          expandedKeys={expandedKeys}\n          autoExpandParent={autoExpandParent}\n        >\n          {loop(gData)}\n        </Tree>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<SearchTree />, mountNode);\n")),(0,l.kt)("h3",{id:"tree-with-line"},"Tree with line"),(0,l.kt)("p",null,"Tree with connected line between nodes, turn on by ",(0,l.kt)("inlineCode",{parentName:"p"},"showLine"),", customize the preseted icon by ",(0,l.kt)("inlineCode",{parentName:"p"},"switcherIcon"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const { TreeNode } = Tree;\n\nclass Demo extends React.Component {\n  state = {\n    showLine: true,\n    showIcon: false,\n  }\n\n  onShowLineChange = showLine => {\n    this.setState({ showLine });\n  }\n\n  onShowIconChange = showIcon => {\n    this.setState({ showIcon });\n  }\n\n  render() {\n    const { showIcon, showLine } = this.state;\n    return (\n      <div>\n        <div style={{ marginBottom: 16 }}>\n          showLine: <Switch checked={showLine} onChange={this.onShowLineChange} />\n          <br />\n          <br />\n          showIcon: <Switch checked={showIcon} onChange={this.onShowIconChange} />\n        </div>\n        <Tree\n          showLine={showLine}\n          showIcon={showIcon}\n          defaultExpandedKeys={[\'0-0-0\', \'0-0-1\', \'0-0-2\']}\n        >\n          <TreeNode icon={<Icon type="carry-out" />} title="parent 1" key="0-0">\n            <TreeNode icon={<Icon type="carry-out" />} title="parent 1-0" key="0-0-0">\n              <TreeNode icon={<Icon type="carry-out" />} title="leaf" key="0-0-0-0" />\n              <TreeNode icon={<Icon type="carry-out" />} title="leaf" key="0-0-0-1" />\n              <TreeNode icon={<Icon type="carry-out" />} title="leaf" key="0-0-0-2" />\n            </TreeNode>\n            <TreeNode icon={<Icon type="carry-out" />} title="parent 1-1" key="0-0-1">\n              <TreeNode icon={<Icon type="carry-out" />} title="leaf" key="0-0-1-0" />\n            </TreeNode>\n            <TreeNode icon={<Icon type="carry-out" />} title="parent 1-2" key="0-0-2">\n              <TreeNode icon={<Icon type="carry-out" />} title="leaf" key="0-0-2-0" />\n              <TreeNode\n                switcherIcon={<Icon type="form" />}\n                icon={<Icon type="carry-out" />}\n                title="leaf"\n                key="0-0-2-1"\n              />\n            </TreeNode>\n          </TreeNode>\n        </Tree>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n')),(0,l.kt)("h3",{id:"customize-icon"},"Customize Icon"),(0,l.kt)("p",null,"You can customize icons for different nodes."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const { TreeNode } = Tree;\n\nReactDOM.render(\n  <Tree\n    showIcon\n    defaultExpandAll\n    defaultSelectedKeys={[\'0-0-0\']}\n    switcherIcon={<Icon type="down" />}\n  >\n    <TreeNode icon={<Icon type="smile-o" />} title="parent 1" key="0-0">\n      <TreeNode icon={<Icon type="meh-o" />} title="leaf" key="0-0-0" />\n      <TreeNode\n        icon={({ selected }) => <Icon type={selected ? \'frown\' : \'frown-o\'} />}\n        title="leaf"\n        key="0-0-1"\n      />\n    </TreeNode>\n  </Tree>,\n  mountNode,\n);\n')),(0,l.kt)("h3",{id:"directory"},"directory"),(0,l.kt)("p",null,"Built-in directory tree. ",(0,l.kt)("inlineCode",{parentName:"p"},"multiple")," support ",(0,l.kt)("inlineCode",{parentName:"p"},"ctrl(Windows)")," / ",(0,l.kt)("inlineCode",{parentName:"p"},"command(Mac)")," selection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const { TreeNode, DirectoryTree } = Tree;\n\nclass Demo extends React.Component {\n  onSelect = (keys, event) => {\n    console.log(\'Trigger Select\', keys, event);\n  };\n\n  onExpand = () => {\n    console.log(\'Trigger Expand\');\n  };\n\n  render() {\n    return (\n      <DirectoryTree multiple defaultExpandAll onSelect={this.onSelect} onExpand={this.onExpand}>\n        <TreeNode title="parent 0" key="0-0">\n          <TreeNode title="leaf 0-0" key="0-0-0" isLeaf />\n          <TreeNode title="leaf 0-1" key="0-0-1" isLeaf />\n        </TreeNode>\n        <TreeNode title="parent 1" key="0-1">\n          <TreeNode title="leaf 1-0" key="0-1-0" isLeaf />\n          <TreeNode title="leaf 1-1" key="0-1-1" isLeaf />\n        </TreeNode>\n      </DirectoryTree>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n')),(0,l.kt)("h3",{id:"customize-collapseexpand-icon"},"Customize collapse/expand icon"),(0,l.kt)("p",null,"customize collapse/expand icon of tree node"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const { TreeNode } = Tree;\n\nclass Demo extends React.Component {\n  onSelect = (selectedKeys, info) => {\n    console.log(\'selected\', selectedKeys, info);\n  };\n\n  render() {\n    return (\n      <Tree\n        showLine\n        switcherIcon={<Icon type="down" />}\n        defaultExpandedKeys={[\'0-0-0\']}\n        onSelect={this.onSelect}\n      >\n        <TreeNode title="parent 1" key="0-0">\n          <TreeNode title="parent 1-0" key="0-0-0">\n            <TreeNode title="leaf" key="0-0-0-0" />\n            <TreeNode title="leaf" key="0-0-0-1" />\n            <TreeNode title="leaf" key="0-0-0-2" />\n          </TreeNode>\n          <TreeNode title="parent 1-1" key="0-0-1">\n            <TreeNode title="leaf" key="0-0-1-0" />\n          </TreeNode>\n          <TreeNode title="parent 1-2" key="0-0-2">\n            <TreeNode title="leaf" key="0-0-2-0" />\n            <TreeNode title="leaf" key="0-0-2-1" />\n          </TreeNode>\n        </TreeNode>\n      </Tree>\n    );\n  }\n}\n\nReactDOM.render(<Demo />, mountNode);\n')),(0,l.kt)("h2",{id:"api"},"API"),(0,l.kt)("h3",{id:"tree-props"},"Tree props"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Property"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Version"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"autoExpandParent"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to automatically expand a parent treeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blockNode"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether treeNode fill remaining horizontal space"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"3.15.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"checkable"),(0,l.kt)("td",{parentName:"tr",align:null},"Adds a ",(0,l.kt)("inlineCode",{parentName:"td"},"Checkbox")," before the treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"checkedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"(Controlled) Specifies the keys of the checked treeNodes (PS: When this specifies the key of a treeNode which is also a parent treeNode, all the children treeNodes of will be checked; and vice versa, when it specifies the key of a treeNode which is a child treeNode, its parent treeNode will also be checked. When ",(0,l.kt)("inlineCode",{parentName:"td"},"checkable")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"checkStrictly")," is true, its object has ",(0,l.kt)("inlineCode",{parentName:"td"},"checked")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"halfChecked")," property. Regardless of whether the child or parent treeNode is checked, they won't impact each other."),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"{checked: string","[","], halfChecked: string","[","]}"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"checkStrictly"),(0,l.kt)("td",{parentName:"tr",align:null},"Check treeNode precisely; parent treeNode and children treeNodes are not associated"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultCheckedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the keys of the default checked treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultExpandAll"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to expand all treeNodes by default"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultExpandedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"Specify the keys of the default expanded treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultExpandParent"),(0,l.kt)("td",{parentName:"tr",align:null},"auto expand parent treeNodes when init"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"3.4.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultSelectedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the keys of the default selected treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"disabled"),(0,l.kt)("td",{parentName:"tr",align:null},"whether disabled the tree"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"3.4.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"draggable"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies whether this Tree is draggable (IE > 8)"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expandedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"(Controlled) Specifies the keys of the expanded treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"filterTreeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"Defines a function to filter (highlight) treeNodes. When the function returns ",(0,l.kt)("inlineCode",{parentName:"td"},"true"),", the corresponding treeNode will be highlighted"),(0,l.kt)("td",{parentName:"tr",align:null},"function(node)"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"loadData"),(0,l.kt)("td",{parentName:"tr",align:null},"Load data asynchronously"),(0,l.kt)("td",{parentName:"tr",align:null},"function(node)"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"loadedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"(Controlled) Set loaded tree nodes. Need work with ",(0,l.kt)("inlineCode",{parentName:"td"},"loadData")),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"3.7.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"multiple"),(0,l.kt)("td",{parentName:"tr",align:null},"Allows selecting multiple treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"selectable"),(0,l.kt)("td",{parentName:"tr",align:null},"whether can be selected"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"selectedKeys"),(0,l.kt)("td",{parentName:"tr",align:null},"(Controlled) Specifies the keys of the selected treeNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"string","[","]"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"showIcon"),(0,l.kt)("td",{parentName:"tr",align:null},"Shows the icon before a TreeNode's title. There is no default style; you must set a custom style for it if set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true")),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"switcherIcon"),(0,l.kt)("td",{parentName:"tr",align:null},"customize collapse/expand icon of tree node"),(0,l.kt)("td",{parentName:"tr",align:null},"React.ReactElement"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},"3.12.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"showLine"),(0,l.kt)("td",{parentName:"tr",align:null},"Shows a connecting line"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onCheck"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onCheck event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function(checkedKeys, e:{checked: bool, checkedNodes, node, event, halfCheckedKeys})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDragEnd"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDragEnd event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDragEnter"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDragEnter event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node, expandedKeys})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDragLeave"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDragLeave event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDragOver"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDragOver event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDragStart"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDragStart event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onDrop"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the onDrop event occurs"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node, dragNode, dragNodesKeys})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onExpand"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when a treeNode is expanded or collapsed"),(0,l.kt)("td",{parentName:"tr",align:null},"function(expandedKeys, {expanded: bool, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onLoad"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when a treeNode is loaded"),(0,l.kt)("td",{parentName:"tr",align:null},"function(loadedKeys, {event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},"3.7.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onRightClick"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the user right clicks a treeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"function({event, node})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onSelect"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback function for when the user clicks a treeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"function(selectedKeys, e:{selected: bool, selectedNodes, node, event})"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"treeData"),(0,l.kt)("td",{parentName:"tr",align:null},"treeNodes data Array, if set it then you need not to construct children TreeNode. (key should be unique across the whole array)"),(0,l.kt)("td",{parentName:"tr",align:null},"array<{ key, title, children, ","[","disabled, selectable] }>"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},"3.19.8")))),(0,l.kt)("h3",{id:"treenode-props"},"TreeNode props"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Property"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Version"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"checkable"),(0,l.kt)("td",{parentName:"tr",align:null},"When Tree is checkable, set TreeNode display Checkbox or not"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null},"3.17.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"disableCheckbox"),(0,l.kt)("td",{parentName:"tr",align:null},"Disables the checkbox of the treeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"disabled"),(0,l.kt)("td",{parentName:"tr",align:null},"Disables the treeNode"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"icon"),(0,l.kt)("td",{parentName:"tr",align:null},"customize icon. When you pass component, whose render will receive full TreeNode props as component props"),(0,l.kt)("td",{parentName:"tr",align:null},"ReactNode/Function(props):ReactNode"),(0,l.kt)("td",{parentName:"tr",align:null},"-"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isLeaf"),(0,l.kt)("td",{parentName:"tr",align:null},"Determines if this is a leaf node(effective when ",(0,l.kt)("inlineCode",{parentName:"td"},"loadData")," is specified)"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"key"),(0,l.kt)("td",{parentName:"tr",align:null},"Used with (default)ExpandedKeys / (default)CheckedKeys / (default)SelectedKeys. P.S.: It must be unique in all of treeNodes of the tree!"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"internal calculated position of treeNode"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"selectable"),(0,l.kt)("td",{parentName:"tr",align:null},"Set whether the treeNode can be selected"),(0,l.kt)("td",{parentName:"tr",align:null},"boolean"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"title"),(0,l.kt)("td",{parentName:"tr",align:null},"Title"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"ReactNode"),(0,l.kt)("td",{parentName:"tr",align:null},"'---'")))),(0,l.kt)("h3",{id:"directorytree-props"},"DirectoryTree props"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Property"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Version"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expandAction"),(0,l.kt)("td",{parentName:"tr",align:null},"Directory open logic, optional ",(0,l.kt)("inlineCode",{parentName:"td"},"false")," ",(0,l.kt)("inlineCode",{parentName:"td"},"'click'")," ",(0,l.kt)("inlineCode",{parentName:"td"},"'doubleClick'")),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"click"),(0,l.kt)("td",{parentName:"tr",align:null},"3.7.0")))),(0,l.kt)("h2",{id:"note"},"Note"),(0,l.kt)("p",null,"Before ",(0,l.kt)("inlineCode",{parentName:"p"},"3.4.0"),": The number of treeNodes can be very large, but when ",(0,l.kt)("inlineCode",{parentName:"p"},"checkable=true"),", it will increase the compute time. So, we cache some calculations (e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"this.treeNodesStates"),") to avoid double computing. But, this brings some restrictions. ",(0,l.kt)("strong",{parentName:"p"},"When you load treeNodes asynchronously, you should render tree like this"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"{\n  this.state.treeData.length ? (\n    <Tree>\n      {this.state.treeData.map(data => (\n        <TreeNode />\n      ))}\n    </Tree>\n  ) : (\n    'loading tree'\n  );\n}\n")),(0,l.kt)("h2",{id:"faq"},"FAQ"),(0,l.kt)("h3",{id:"how-to-hide-file-icon-when-use-showline"},"How to hide file icon when use showLine?"),(0,l.kt)("p",null,"File icon realize by using switcherIcon. You can overwrite the style to hide it: ",(0,l.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/long-moon-go9e2"},"https://codesandbox.io/s/long-moon-go9e2")))}u.isMDXComponent=!0},30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(n),k=r,m=u["".concat(d,".").concat(k)]||u[k]||c[k]||l;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=u;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);